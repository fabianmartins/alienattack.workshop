import { Construct, IConstruct } from '@aws-cdk/cdk';
import { Connections, IConnectable } from './connections';
import { IPortRange, ISecurityGroupRule } from './security-group-rule';
import { IVpcNetwork } from './vpc-ref';
export interface ISecurityGroup extends IConstruct, ISecurityGroupRule, IConnectable {
    /**
     * ID for the current security group
     */
    readonly securityGroupId: string;
    /**
     * Add an ingress rule for the current security group
     *
     * `remoteRule` controls where the Rule object is created if the peer is also a
     * securityGroup and they are in different stack. If false (default) the
     * rule object is created under the current SecurityGroup object. If true and the
     * peer is also a SecurityGroup, the rule object is created under the remote
     * SecurityGroup object.
     */
    addIngressRule(peer: ISecurityGroupRule, connection: IPortRange, description?: string, remoteRule?: boolean): void;
    /**
     * Add an egress rule for the current security group
     *
     * `remoteRule` controls where the Rule object is created if the peer is also a
     * securityGroup and they are in different stack. If false (default) the
     * rule object is created under the current SecurityGroup object. If true and the
     * peer is also a SecurityGroup, the rule object is created under the remote
     * SecurityGroup object.
     */
    addEgressRule(peer: ISecurityGroupRule, connection: IPortRange, description?: string, remoteRule?: boolean): void;
    /**
     * Export the security group
     */
    export(): SecurityGroupImportProps;
}
export interface SecurityGroupImportProps {
    /**
     * ID of security group
     */
    securityGroupId: string;
}
/**
 * A SecurityGroup that is not created in this template
 */
export declare abstract class SecurityGroupBase extends Construct implements ISecurityGroup {
    /**
     * Return whether the indicated object is a security group
     */
    static isSecurityGroup(construct: any): construct is SecurityGroupBase;
    abstract readonly securityGroupId: string;
    readonly canInlineRule = false;
    readonly connections: Connections;
    /**
     * FIXME: Where to place this??
     */
    readonly defaultPortRange?: IPortRange;
    constructor(scope: Construct, id: string);
    readonly uniqueId: string;
    addIngressRule(peer: ISecurityGroupRule, connection: IPortRange, description?: string, remoteRule?: boolean): void;
    addEgressRule(peer: ISecurityGroupRule, connection: IPortRange, description?: string, remoteRule?: boolean): void;
    toIngressRuleJSON(): any;
    toEgressRuleJSON(): any;
    /**
     * Export this SecurityGroup for use in a different Stack
     */
    abstract export(): SecurityGroupImportProps;
}
export interface SecurityGroupProps {
    /**
     * The name of the security group. For valid values, see the GroupName
     * parameter of the CreateSecurityGroup action in the Amazon EC2 API
     * Reference.
     *
     * It is not recommended to use an explicit group name.
     *
     * @default If you don't specify a GroupName, AWS CloudFormation generates a
     * unique physical ID and uses that ID for the group name.
     */
    groupName?: string;
    /**
     * A description of the security group.
     *
     * @default The default name will be the construct's CDK path.
     */
    description?: string;
    /**
     * The VPC in which to create the security group.
     */
    vpc: IVpcNetwork;
    /**
     * Whether to allow all outbound traffic by default.
     *
     * If this is set to true, there will only be a single egress rule which allows all
     * outbound traffic. If this is set to false, no outbound traffic will be allowed by
     * default and all egress traffic must be explicitly authorized.
     *
     * @default true
     */
    allowAllOutbound?: boolean;
}
/**
 * Creates an Amazon EC2 security group within a VPC.
 *
 * This class has an additional optimization over imported security groups that it can also create
 * inline ingress and egress rule (which saves on the total number of resources inside
 * the template).
 */
export declare class SecurityGroup extends SecurityGroupBase {
    /**
     * Import an existing SecurityGroup
     */
    static import(scope: Construct, id: string, props: SecurityGroupImportProps): ISecurityGroup;
    /**
     * An attribute that represents the security group name.
     */
    readonly groupName: string;
    /**
     * An attribute that represents the physical VPC ID this security group is part of.
     */
    readonly vpcId: string;
    /**
     * The ID of the security group
     */
    readonly securityGroupId: string;
    private readonly securityGroup;
    private readonly directIngressRules;
    private readonly directEgressRules;
    private readonly allowAllOutbound;
    constructor(scope: Construct, id: string, props: SecurityGroupProps);
    /**
     * Export this SecurityGroup for use in a different Stack
     */
    export(): SecurityGroupImportProps;
    addIngressRule(peer: ISecurityGroupRule, connection: IPortRange, description?: string, remoteRule?: boolean): void;
    addEgressRule(peer: ISecurityGroupRule, connection: IPortRange, description?: string, remoteRule?: boolean): void;
    /**
     * Add a direct ingress rule
     */
    private addDirectIngressRule;
    /**
     * Return whether the given ingress rule exists on the group
     */
    private hasIngressRule;
    /**
     * Add a direct egress rule
     */
    private addDirectEgressRule;
    /**
     * Return whether the given egress rule exists on the group
     */
    private hasEgressRule;
    /**
     * Add the default egress rule to the securityGroup
     *
     * This depends on allowAllOutbound:
     *
     * - If allowAllOutbound is true, we *TECHNICALLY* don't need to do anything, because
     *   EC2 is going to create this default rule anyway. But, for maximum readability
     *   of the template, we will add one anyway.
     * - If allowAllOutbound is false, we add a bogus rule that matches no traffic in
     *   order to get rid of the default "all outbound" rule that EC2 creates by default.
     *   If other rules happen to get added later, we remove the bogus rule again so
     *   that it doesn't clutter up the template too much (even though that's not
     *   strictly necessary).
     */
    private addDefaultEgressRule;
    /**
     * Remove the bogus rule if it exists
     */
    private removeNoTrafficRule;
}
export interface ConnectionRule {
    /**
     * The IP protocol name (tcp, udp, icmp) or number (see Protocol Numbers).
     * Use -1 to specify all protocols. If you specify -1, or a protocol number
     * other than tcp, udp, icmp, or 58 (ICMPv6), traffic on all ports is
     * allowed, regardless of any ports you specify. For tcp, udp, and icmp, you
     * must specify a port range. For protocol 58 (ICMPv6), you can optionally
     * specify a port range; if you don't, traffic for all types and codes is
     * allowed.
     *
     * @default tcp
     */
    protocol?: string;
    /**
     * Start of port range for the TCP and UDP protocols, or an ICMP type number.
     *
     * If you specify icmp for the IpProtocol property, you can specify
     * -1 as a wildcard (i.e., any ICMP type number).
     */
    fromPort: number;
    /**
     * End of port range for the TCP and UDP protocols, or an ICMP code.
     *
     * If you specify icmp for the IpProtocol property, you can specify -1 as a
     * wildcard (i.e., any ICMP code).
     *
     * @default If toPort is not specified, it will be the same as fromPort.
     */
    toPort?: number;
    /**
     * Description of this connection. It is applied to both the ingress rule
     * and the egress rule.
     *
     * @default No description
     */
    description?: string;
}
