import cloudwatch = require('@aws-cdk/aws-cloudwatch');
import iam = require('@aws-cdk/aws-iam');
import cdk = require('@aws-cdk/cdk');
import { LogStream } from './log-stream';
import { MetricFilter } from './metric-filter';
import { IFilterPattern } from './pattern';
import { ILogSubscriptionDestination, SubscriptionFilter } from './subscription-filter';
export interface ILogGroup extends cdk.IConstruct {
    /**
     * The ARN of this log group
     */
    readonly logGroupArn: string;
    /**
     * The name of this log group
     */
    readonly logGroupName: string;
    /**
     * Create a new Log Stream for this Log Group
     *
     * @param scope Parent construct
     * @param id Unique identifier for the construct in its parent
     * @param props Properties for creating the LogStream
     */
    newStream(scope: cdk.Construct, id: string, props?: NewLogStreamProps): LogStream;
    /**
     * Create a new Subscription Filter on this Log Group
     *
     * @param scope Parent construct
     * @param id Unique identifier for the construct in its parent
     * @param props Properties for creating the SubscriptionFilter
     */
    newSubscriptionFilter(scope: cdk.Construct, id: string, props: NewSubscriptionFilterProps): SubscriptionFilter;
    /**
     * Create a new Metric Filter on this Log Group
     *
     * @param scope Parent construct
     * @param id Unique identifier for the construct in its parent
     * @param props Properties for creating the MetricFilter
     */
    newMetricFilter(scope: cdk.Construct, id: string, props: NewMetricFilterProps): MetricFilter;
    /**
     * Export this LogGroup
     */
    export(): LogGroupImportProps;
    /**
     * Extract a metric from structured log events in the LogGroup
     *
     * Creates a MetricFilter on this LogGroup that will extract the value
     * of the indicated JSON field in all records where it occurs.
     *
     * The metric will be available in CloudWatch Metrics under the
     * indicated namespace and name.
     *
     * @param jsonField JSON field to extract (example: '$.myfield')
     * @param metricNamespace Namespace to emit the metric under
     * @param metricName Name to emit the metric under
     * @returns A Metric object representing the extracted metric
     */
    extractMetric(jsonField: string, metricNamespace: string, metricName: string): cloudwatch.Metric;
    /**
     * Give permissions to write to create and write to streams in this log group
     */
    grantWrite(principal?: iam.IPrincipal): void;
    /**
     * Give the indicated permissions on this log group and all streams
     */
    grant(principal?: iam.IPrincipal, ...actions: string[]): void;
}
/**
 * Properties for importing a LogGroup
 */
export interface LogGroupImportProps {
    logGroupArn: string;
}
/**
 * An CloudWatch Log Group
 */
export declare abstract class LogGroupBase extends cdk.Construct implements ILogGroup {
    /**
     * The ARN of this log group
     */
    abstract readonly logGroupArn: string;
    /**
     * The name of this log group
     */
    abstract readonly logGroupName: string;
    /**
     * Create a new Log Stream for this Log Group
     *
     * @param scope Parent construct
     * @param id Unique identifier for the construct in its parent
     * @param props Properties for creating the LogStream
     */
    newStream(scope: cdk.Construct, id: string, props?: NewLogStreamProps): LogStream;
    /**
     * Create a new Subscription Filter on this Log Group
     *
     * @param scope Parent construct
     * @param id Unique identifier for the construct in its parent
     * @param props Properties for creating the SubscriptionFilter
     */
    newSubscriptionFilter(scope: cdk.Construct, id: string, props: NewSubscriptionFilterProps): SubscriptionFilter;
    /**
     * Create a new Metric Filter on this Log Group
     *
     * @param scope Parent construct
     * @param id Unique identifier for the construct in its parent
     * @param props Properties for creating the MetricFilter
     */
    newMetricFilter(scope: cdk.Construct, id: string, props: NewMetricFilterProps): MetricFilter;
    abstract export(): LogGroupImportProps;
    /**
     * Extract a metric from structured log events in the LogGroup
     *
     * Creates a MetricFilter on this LogGroup that will extract the value
     * of the indicated JSON field in all records where it occurs.
     *
     * The metric will be available in CloudWatch Metrics under the
     * indicated namespace and name.
     *
     * @param jsonField JSON field to extract (example: '$.myfield')
     * @param metricNamespace Namespace to emit the metric under
     * @param metricName Name to emit the metric under
     * @returns A Metric object representing the extracted metric
     */
    extractMetric(jsonField: string, metricNamespace: string, metricName: string): cloudwatch.Metric;
    /**
     * Give permissions to write to create and write to streams in this log group
     */
    grantWrite(principal?: iam.IPrincipal): void;
    /**
     * Give the indicated permissions on this log group and all streams
     */
    grant(principal?: iam.IPrincipal, ...actions: string[]): void;
}
/**
 * Properties for a LogGroup
 */
export interface LogGroupProps {
    /**
     * Name of the log group.
     *
     * @default Automatically generated
     */
    logGroupName?: string;
    /**
     * How long, in days, the log contents will be retained.
     *
     * To retain all logs, set this value to Infinity.
     *
     * @default 731 days (2 years)
     */
    retentionDays?: number;
    /**
     * Retain the log group if the stack or containing construct ceases to exist
     *
     * Normally you want to retain the log group so you can diagnose issues
     * from logs even after a deployment that no longer includes the log group.
     * In that case, use the normal date-based retention policy to age out your
     * logs.
     *
     * @default true
     */
    retainLogGroup?: boolean;
}
/**
 * Define a CloudWatch Log Group
 */
export declare class LogGroup extends LogGroupBase {
    /**
     * Import an existing LogGroup
     */
    static import(scope: cdk.Construct, id: string, props: LogGroupImportProps): ILogGroup;
    /**
     * The ARN of this log group
     */
    readonly logGroupArn: string;
    /**
     * The name of this log group
     */
    readonly logGroupName: string;
    constructor(scope: cdk.Construct, id: string, props?: LogGroupProps);
    /**
     * Export this LogGroup
     */
    export(): LogGroupImportProps;
}
/**
 * Properties for a new LogStream created from a LogGroup
 */
export interface NewLogStreamProps {
    /**
     * The name of the log stream to create.
     *
     * The name must be unique within the log group.
     *
     * @default Automatically generated
     */
    logStreamName?: string;
}
/**
 * Properties for a new SubscriptionFilter created from a LogGroup
 */
export interface NewSubscriptionFilterProps {
    /**
     * The destination to send the filtered events to.
     *
     * For example, a Kinesis stream or a Lambda function.
     */
    destination: ILogSubscriptionDestination;
    /**
     * Log events matching this pattern will be sent to the destination.
     */
    filterPattern: IFilterPattern;
}
/**
 * Properties for a MetricFilter created from a LogGroup
 */
export interface NewMetricFilterProps {
    /**
     * Pattern to search for log events.
     */
    filterPattern: IFilterPattern;
    /**
     * The namespace of the metric to emit.
     */
    metricNamespace: string;
    /**
     * The name of the metric to emit.
     */
    metricName: string;
    /**
     * The value to emit for the metric.
     *
     * Can either be a literal number (typically "1"), or the name of a field in the structure
     * to take the value from the matched event. If you are using a field value, the field
     * value must have been matched using the pattern.
     *
     * If you want to specify a field from a matched JSON structure, use '$.fieldName',
     * and make sure the field is in the pattern (if only as '$.fieldName = *').
     *
     * If you want to specify a field from a matched space-delimited structure,
     * use '$fieldName'.
     *
     * @default "1"
     */
    metricValue?: string;
    /**
     * The value to emit if the pattern does not match a particular event.
     *
     * @default No metric emitted.
     */
    defaultValue?: number;
}
